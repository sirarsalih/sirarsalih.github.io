---
layout: post
title: The Release Night from Hell
tags: [dotnet]
---
Friday October 14, 2016. That Friday was supposed to be like any other. I would be heading off to work, I would do what I was planning to do then head home and embrace the weekend. It would be a good Friday concluding a long week. There was only one thing that stood out that day; it was release day. I work in a two-man development team and my colleague was on holiday abroad. I was supposed to release what we have been developing for the past four weeks (although we're capable of doing continuous delivery to production, the major bulk of our release follows a four week cycle due to legacy dependencies), this wasn't really a big deal since I'd been soley releasing our application for quite a while. The only thing that stood out this time is that I would be alone. I thought it no big deal, I've done it in the past and so got the experience to handle issues. Also, during each release my colleague and I had finessed the process and continuously updated all documentation. I was ready for this (boy, was I wrong).

The day started with me arriving at work a bit later than usual, reason being that I had been working a bit late the day before to finalize a demo for the business. I was very excited that day. I was going to show off something new of version Y, and then I was going to start scheduling the release of version X of our application. I ran the demo at 10:00 AM, finishing off at 10:30 AM. The business were happy and I was happy. I grabbed some lunch, then headed back to my computer to get mentally ready for the release. I like to be efficient, so I thought, maybe I can code some of the changes that the business pointed out during the demo to version Y, before I get started of scheduling the version X release. I did the changes and finished off at around 02:00 PM. Alright, I thought, time to get started on the release. I set my status on Skype to Busy. Our application consists of five components that need to be deployed. We schedule the deployment of each component so that this happens automatically. This Friday it was a bit different though. One of the components had to be manually deployed due to a server change, we agreed that the manual trigger would be made by the infrastructure team since the server change was made by them. They would click the button on that one. The rest of the components would be automatically deployed at different time intervals. Of course, before I got to this bit, I had to start merging the code. I was in for a treat.

We use git and follow the git flow principle. During this release, we had done changes to the two major components of our application. Therefore I had two code bases which I had to merge. I started with the easy one. This component is the front-end part of our application. Usually, it's quite straightforward to merge this code, I seldom get any issues. I checked out master, pulled with a rebase then merged the release branch with master. Conflicts everywhere. I thought it was strange, I hadn't witnessed that many conflicts in this component before. Our front-end changes are usually straightforward. I started fixing the conflicts. Most of the changes here were made by my colleague, since he wasn't around, I sticked with the changes made in the release branch. I finished merging and pushed the code to master at around 03:00 PM. My plan was to finish everything and wrap up by 05:00 PM, so far so good.

I moved on to the next major component. This is the back-end component, which has many dependencies on a legacy system (which will be released this Friday by the infrastructure team). The dependency artifacts that our component needs, are fetched through NuGet packages. There are two feeds the host the artifacts, one for the develop and one for the release/master branches. I checked out master, pulled with a rebase and merged release with master. Conflicts and project load failures, this was expected. Windows trailing whitespaces are considered conflicts by git (I learned later that I could configure my editor to ignore this). Now the next thing that would happen (I believe) would be the fatal mistake that would change the outcome of the rest of that day. There were two sets of conflicts; all the packages.config and the project csproj files. For the packages.config files I can either choose to keep source or target, it doesn't really matter. We have a script that I can run afterwards that will switch the NuGet feeds from develop to release then update all the packages.config files in the solution with the correct package versions. Running a restore of the solution will then fetch me the latest packages from the correct feed. So I did that. The csproj was a different story though. Instead of clicking on either keep source or target, I should have seen with my eyes what kind of conflicts there were and handled them accordingly. For some reason, I chose keep source.